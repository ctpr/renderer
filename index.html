<!DOCTYPE html>
<html ng-app="demo">
    <head>
        <title>Hello SimScale</title>
        <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.3/angular.min.js"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/threejs/r84/three.min.js"></script>
        <script src="js/threejs/Detector.js"></script>
        <!-- <script src="js/threejs/Projector.js"></script> -->
        <script src="js/threejs/CanvasRenderer.js"></script>
        <script src="js/threejs/PLYLoader.js"></script>
        <script src="js/threejs/OrbitControls.js"></script>
        <script src="js/threejs/Lut.js"></script>
        <script src="js/loader.js"></script>
    </head>

    <body>
        <div ng-controller="ModelSelector">
            <script>
            function updateGeometries (paths) {
                $.each(paths, function() {
                    $("<option value='http://35.158.16.68:9000/geometries/" + this + "'>" + this + "</option>").appendTo("#geometry_files");
                });
            }
            </script>
            <select name="Files" id="geometry_files" onchange="replaceModels(this.options[this.selectedIndex].value)">
                <option value="none">none</option>
            </select>
            <select name="Shading Mode:" id="shading_mode" onchange="updateMaterials()">
                <option value="phong">Phong</option>
                <option value="lambert">Lambert</option>
                <option value="basic">Basic</option>
            </select>
            <select name="Color Mode:" id="color_mode" onchange="updateMaterials()">
                <option value="vertex">Vertex Color</option>
                <option value="single">Single Color</option>
            </select>
            <select name="Color Mapping:" id="color_mapping" onchange="updateColors()">
                <option value="scalar">Scalar Mapping</option>
                <option value="color">Color Mapping</option>
                <option value="normal">Normal Mapping</option>
            </select>
            <select name="Color Map:" id="color_map" onchange="updateColors()">
                <option value="cooltowarm">Cool to warm</option>
                <option value="rainbow">Rainbow</option>
                <option value="blackbody">Black body</option>
                <option value="grayscale">Greyscale</option>
            </select>
            <font face="courier" size="1">SimScale PostProcessing Demo v1.0</font>
        </div>

        <div style="border:0px">
        <script type="text/javascript">
            var demo = {
                scene: null,
                camera: null,
                renderer: null,
                container: null,
                controls: null,
                clock: null,
                hasWebGL: false,
                raycaster: null,
                meshObjects: null,

                init: function() {
                    // Window layout
                    var windowWidth = window.innerWidth;
                    var windowHeight = window.innerHeight;
                    var ASPECT = windowWidth / windowHeight;

                    // Store a reference to the loaded mesh object(s)
                    this.meshObjects = [];

                    // Main scene
                    this.scene = new THREE.Scene();

                    // Ambient light initialization
                    this.scene.add( new THREE.AmbientLight(0x606060, 1.0) );
                    // Create a directional light
                    var dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
                    dirLight.position.set(2.0, 2.0, 10.0);

                    // Camera initialization
                    this.camera = new THREE.PerspectiveCamera(60, ASPECT, 0.001, 10000.0);
                    this.scene.add(this.camera);
                    this.camera.position.set(-2, 2, -2);
                    this.camera.lookAt(new THREE.Vector3(0,0,0));

                    // Add the directional light to the camera
                    this.camera.add(dirLight);
                    this.camera.add(dirLight.target);

                    if(Detector.webgl) {
                        this.renderer = new THREE.WebGLRenderer({antialias:true});
                        this.hasWebGL = true;
                    } else {
                        this.renderer = new THREE.CanvasRenderer();
                    }
                    this.renderer.setSize(windowWidth, windowHeight);
                    this.renderer.setClearColor(0xffffff, 1);
                    this.renderer.shadowMap.enabled = true;
                    this.renderer.shadowMapSoft = true;

                    this.container = document.createElement('div');
                    document.body.appendChild(this.container);
                    this.container.appendChild(this.renderer.domElement);

                    // Scene interaction setup
                    this.raycaster = new THREE.Raycaster();
                    this.mouse = new THREE.Vector2();

                    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                    this.controls.target = new THREE.Vector3(0, 0, 0);
                    this.controls.maxDistance = 10000.0;

                    this.clock = new THREE.Clock();
                }
            };

            // Clear the scene of all meshes
            function clearScene() {
                for (let i = demo.scene.children.length - 1; i >= 0 ; i--) {
                    let child = demo.scene.children[ i ];
                    if ( child instanceof THREE.Mesh ) {
                        demo.scene.remove(child);
                    }
                }
                demo.meshObjects = [];
            }

            // Material builder
            function generateMaterial() {
                var colorSelect = document.getElementById("color_mode");
                var shadeSelect = document.getElementById("shading_mode");

                requestColor = colorSelect.options[colorSelect.selectedIndex].value;
                requestShade = shadeSelect.options[shadeSelect.selectedIndex].value;

                var material = new THREE.MeshBasicMaterial({ color: 0xff4242 });

                if(!demo.hasWebGL) {
                    window.alert("No WebGL available - using Basic material model !");
                    return material;
                }

                if (requestShade === "lambert") {
                    material = new THREE.MeshLambertMaterial({color: 0x42ff42, wireframe: false});
                } else if (requestShade === "phong") {
                    material = new THREE.MeshPhongMaterial({color: 0x4242ff, wireframe: false});
                }

                if (requestColor === "vertex") {
                    material.color.setHex(0xffffff);
                    material.vertexColors = THREE.VertexColors;
                }

                // Double sided would be better for triangle rendering
                // Unfortunately, it causes artifacts in many models
                // material.side = THREE.DoubleSide;
                material.shading = THREE.SmoothShading;

                return material;
            }

            // Apply lookUpTable to map scalar value to a color
            function mapColor(scalar) {
                var colorMapSelect = document.getElementById("color_map");
                colorMap = colorMapSelect.options[colorMapSelect.selectedIndex].value;

                lut = new THREE.Lut( colorMap, '256' );
                lut.setMin( 0.0 );
                lut.setMax( 1.0 );

                var legend = lut.setLegendOn( { 'layout':'vertical', 'position': { 'x': 2.4, 'y': 0.0, 'z': -4.0 } } );
                var labels = lut.setLegendLabels( { 'title': 'Scalar', 'um': 'U', 'ticks': 5 } );
                demo.camera.add( legend );
                demo.camera.add( labels['title'] );
                for ( var i = 0; i < Object.keys( labels[ 'ticks' ] ).length; i++ ) {
                    demo.camera.add ( labels[ 'ticks' ][ i ] );
                    demo.camera.add ( labels[ 'lines' ][ i ] );
                }

                color = lut.getColor( scalar );

                if ( color == undefined ) {
                    return [scalar, 0.0, 0.0];
                } else {
                    return [color.r, color.g, color.b];
                }
            }

            // Generate the color mapping for an input mesh
            function generateColorMapping(mesh) {
                // Get current color mapping mode
                var colorSelect = document.getElementById("color_mapping");
                mappingColor = colorSelect.options[colorSelect.selectedIndex].value;

                var colors = [];

                if (mappingColor === "scalar") {
                    // mapping scalars to color
                    var scalarAttribute = mesh.geometry.getAttribute("scalar");
                    if (scalarAttribute && scalarAttribute.length > 0) {
                        for ( var i = 0; i < scalarAttribute.length; i ++ ) {
                            color = mapColor(scalarAttribute.array[i]);
                            colors.push(color[0], color[1], color[2]);
                        }
                    } else {
                        window.alert("No scalar input for scalar color mapping");
                        return;
                    }
                } else if (mappingColor === "color") {
                    // Color mode
                    // FIXME: once a color has been mapped, this actually won't be able to get the original color back unless we are reloading the mesh
                    var colorAttribute = mesh.geometry.getAttribute("color");
                    if (colorAttribute && colorAttribute.length > 0) {
                        colors = colorAttribute.array;
                    } else {
                        window.alert("No color input for color mapping");
                        return;
                    }
                } else if (mappingColor === "normal") {
                    // mapping normals to color
                    var normalAttribute = mesh.geometry.getAttribute("normal");
                    if (normalAttribute && normalAttribute.length > 0) {
                        for ( var i = 0; i < normalAttribute.length; i ++ ) {
                            colors.push( normalAttribute.array[i] );
                        }
                    } else {
                        window.alert("No normal input for normal color mapping");
                        return;
                    }
                }

                var colorAttribute = mesh.geometry.getAttribute("color");
                if (colorAttribute) {
                    mesh.geometry.removeAttribute( 'color' );
                }

                mesh.geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
            }

            // Create mesh with material, compute normals, bounding box
            // Map scalar values to colors (if present)
            function generateMesh(geometry, material) {
                // Actually generate the mesh
                var mesh = new THREE.Mesh(geometry, material);

                mesh.geometry.computeFaceNormals();
                mesh.geometry.computeVertexNormals();
                mesh.geometry.computeBoundingBox();

                generateColorMapping(mesh);

                return mesh;
            }

            // Clear scene and load new model
            function replaceModels(url) {
                clearScene();
                var loader = new THREE.PLYLoader();
                loader.load(url, function(geometry) {
                    var material = generateMaterial();

                    // Create the mesh
                    var mesh = generateMesh(geometry, material);
                    var boundingBox = mesh.geometry.boundingBox;

                    var center = new THREE.Vector3();
                    center.subVectors( boundingBox.max, boundingBox.min );
                    center.multiplyScalar( 0.5 );
                    center.add( boundingBox.min );

                    var position = new THREE.Vector3();
                    position.subVectors( boundingBox.max, boundingBox.min );
                    position.multiplyScalar( 1.5 );
                    position.add( boundingBox.min );

                    demo.camera.lookAt(center);
                    demo.camera.position.set(position.x, position.y, position.z);
                    demo.scene.add(mesh);
                    demo.meshObjects.push(mesh);
                });
            }

            // Re-generate the materials for all present meshes
            function updateMaterials() {
                for (let i = demo.scene.children.length - 1; i >= 0 ; i--) {
                    let child = demo.scene.children[ i ];
                    if ( child instanceof THREE.Mesh ) {
                        child.material = generateMaterial();
                        child.material.needsUpdate = true;
                    }
                }
            }

            // Re-generate the color for all present meshes
            function updateColors() {
                for (let i = demo.scene.children.length - 1; i >= 0 ; i--) {
                    let child = demo.scene.children[ i ];
                    if ( child instanceof THREE.Mesh ) {
                        generateColorMapping(child);
                    }
                }
            }

            // Animate the scene
            function animate() {
                requestAnimationFrame(animate);
                render();
                update();
            }

            // Update controls
            function update() {
                demo.controls.update(demo.clock.getDelta());
            }

            // Render the scene
            function render() {
                if (demo.renderer) {
                    demo.renderer.render( demo.scene, demo.camera );
                }
            }

            // Initialize on page load
            function initialize() {
                demo.init();
                animate();
            }

            // Get interpolated value on face
            function getInterpolatedProperty( propertyType, intersects ) {
                var iPt = intersects[ 0 ].point;
                var iFace = intersects[ 0 ].face;
                var iPosAttr = intersects[ 0 ].object.geometry.getAttribute("position");
                var iRequestAttr = intersects[ 0 ].object.geometry.getAttribute(propertyType);
                if (iPosAttr && iRequestAttr && iPosAttr.length > 0 && iRequestAttr.length > 0) {
                    // get all vertices to compute barycentric coordinates
                    var vertex0 = new THREE.Vector3(iPosAttr.array[3*iFace.a],
                                                    iPosAttr.array[3*iFace.a + 1],
                                                    iPosAttr.array[3*iFace.a + 2]);
                    var vertex1 = new THREE.Vector3(iPosAttr.array[3*iFace.b],
                                                    iPosAttr.array[3*iFace.b + 1],
                                                    iPosAttr.array[3*iFace.b + 2]);
                    var vertex2 = new THREE.Vector3(iPosAttr.array[3*iFace.c],
                                                    iPosAttr.array[3*iFace.c + 1],
                                                    iPosAttr.array[3*iFace.c + 2]);

                    var triangle = new THREE.Triangle ( vertex0, vertex1, vertex2 );
                    var bary = triangle.barycoordFromPoint( iPt );

                    // use barycentric coordinates to compute interpolated value
                    // FIXME: assuming single value attribute here
                    //        could be extended to support more dimensions
                    requestValue = iRequestAttr.array[iFace.a] * bary.x +
                                   iRequestAttr.array[iFace.b] * bary.y +
                                   iRequestAttr.array[iFace.c] * bary.z;

                    // DEBUG
                    // window.alert("InterC: "+iPt.x+" "+iPt.y+" "+iPt.z+"\n"+
                    //              "InterF: "+iFace.a+" "+iFace.b+" "+iFace.c+"\n"+
                    //              "InterVC: "+iPosAttr.array.length+"\n"+
                    //              "InterF: "+vertex0.x+" "+vertex0.y+" "+vertex0.z+"\n"+
                    //              "InterF: "+vertex1.x+" "+vertex1.y+" "+vertex1.z+"\n"+
                    //              "InterF: "+vertex2.x+" "+vertex2.y+" "+vertex2.z+"\n"+
                    //              "BaryC: "+bary.x+" "+bary.y+" "+bary.z+"\n"+
                    //              "RequV: "+requestValue);

                    return requestValue;
                 }
            }

            var lastTouchStart;

            function onDocumentTouchStart( event ) {
                var now = new Date().getTime();
                var timeBetween = now - lastTouchStart;
                lastTouchStart = now;
                // Detect a double tap
                if((timeBetween < 500) && (timeBetween > 0)){
                    event.clientX = event.touches[0].clientX;
                    event.clientY = event.touches[0].clientY;
                    onDocumentDblClick( event );
                }
            }

            function onDocumentDblClick( event ) {
                // FIXME: adding HTML UI elements above the scene
                // shifts the render window down and makes this inaccurate
                demo.mouse.x = ( event.clientX / demo.renderer.domElement.clientWidth ) * 2 - 1;
                demo.mouse.y = - ( event.clientY / demo.renderer.domElement.clientHeight ) * 2 + 1;
                demo.raycaster.setFromCamera( demo.mouse, demo.camera );
                var intersects = demo.raycaster.intersectObjects( demo.meshObjects );
                if ( intersects.length > 0 ) {
                    var scalarAtIntersection = getInterpolatedProperty("scalar", intersects);
                    window.alert("Scalar: "+scalarAtIntersection);
                }
            }

            function onWindowResize() {
                demo.camera.aspect = window.innerWidth / window.innerHeight;
                demo.camera.updateProjectionMatrix();
                demo.renderer.setSize( window.innerWidth, window.innerHeight );
            }

            if (window.addEventListener) {
                window.addEventListener( 'load', initialize, false );
                window.addEventListener( 'resize', onWindowResize, false );
            } else if (window.attachEvent) {
                window.attachEvent( 'onload', initialize );
            } else {
                window.onload = initialize;
            }

            if (document.addEventListener) {
                document.addEventListener( 'dblclick', onDocumentDblClick, false );
                document.addEventListener( 'touchstart', onDocumentTouchStart, false );
            }

        </script>
        </div>
    </body>
</html>
